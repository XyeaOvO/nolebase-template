# 📚 第五章 网络层：控制平面（一）
### 🎯 本章学习目标

1.  **理解网络控制平面的基本原理** 🌱
    *   传统路由算法 (Traditional routing algorithms)
    *   SDN 控制器 (SDN controllers)
    *   网络管理与配置 (Network management, configuration)
2.  **了解控制平面在互联网中的实例化与实现** 🔍
    *   路由协议：$\boxed{OSPF}$ (Open Shortest Path First), $\boxed{BGP}$ (Border Gateway Protocol)
    *   SDN 相关：$\boxed{OpenFlow}$, ODL (OpenDaylight) 和 ONOS 控制器
    *   $\boxed{ICMP}$ (Internet Control Message Protocol，互联网控制报文协议)
    *   网络管理协议：$\boxed{SNMP}$ (Simple Network Management Protocol，简单网络管理协议), $\boxed{YANG}$/$\boxed{NETCONF}$

---

### 🗺️ 网络层：“控制平面”内容导览

1.  **引言** (Introduction)
2.  **路由协议** (Routing protocols)
    *   **链路状态 (Link State, LS) 算法**
    *   **距离向量 (Distance Vector, DV) 算法**
3.  ISP内部路由: OSPF (Intra-ISP routing: OSPF)
4.  ISP间路由: BGP (Routing among ISPs: BGP)
5.  SDN 控制平面 (SDN control plane)
6.  互联网控制报文协议 (Internet Control Message Protocol, ICMP)
7.  网络管理与配置 (Network management, configuration)
    *   SNMP
    *   NETCONF/YANG

---

### 0. 引言 (Introduction)

#### 0.1 网络层功能回顾 🧠

网络层主要有两个核心功能：

*   **转发 (Forwarding)**: 属于 **数据平面 (Data Plane)**。指路由器根据转发表将分组从其输入端口转移到正确的输出端口。
*   **路由 (Routing)**: 属于 **控制平面 (Control Plane)**。确定分组从源到目的地所经过的路径。这是通过路由算法来实现的。

#### 0.2 构建网络控制平面的两种方法 ✨

1.  **每路由器控制 (Per-router control) (传统方式)**
    *   每个路由器都运行路由算法，并相互交换路由信息。
    *   控制平面功能分布在各个路由器中。
    *   如下图所示，每个路由器内部都有一个路由算法模块，它们共同构成了控制平面。数据平面则负责根据本地转发表（由控制平面计算得出）转发数据包。
![](Pic/Pasted%20image%2020250508201714.png)

2.  **逻辑集中式控制 (Logically centralized control) (软件定义网络 - SDN)**
    *   一个远程的中央控制器计算并分发转发表给网络中的所有路由器。
    *   路由器变成了简单的转发设备，其控制逻辑集中在控制器上。
    *   如下图所示，远程控制器 (Remote Controller) 负责计算，并将转发表下发给各个路由器中的 CA (Control Agent) 模块，CA 再更新数据平面的转发表。

![](Pic/Pasted%20image%2020250508201952.png)

---

### 1. 路由协议 (Routing Protocols)

#### 1.1 概述 🌐

*   **路由协议目标 (Routing protocol goal)**: 确定从发送主机到接收主机，经过路由器网络的 "好" 路径 (或称路由)。
*   **路径 (Path)**: 分组从初始源主机到最终目标主机所经过的一系列路由器。
*   **"好" (Good)**: 通常指具有最小 "成本" (cost)、"最快" (fastest) 或 "最不拥塞" (least congested) 的路径。
*   **路由选择 (Routing)**: 是网络领域一个 "Top-10" 的挑战性问题！
![](Pic/Pasted%20image%2020250508202737.png)
#### 1.2 图抽象与链路成本 📉

网络通常被抽象为一个图 $G = (N, E)$：

*   $N$: 路由器集合，例如 $N = \{u, v, w, x, y, z\}$
*   $E$: 链路集合，例如 $E = \{(u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)\}$
*   $\boxed{c_{a,b}}$: 连接节点 $a$ 和 $b$ 的直连链路的成本。
    *   例如，$c_{w,z} = 5$，$c_{u,z} = \infty$ (如果 $u$ 和 $z$ 不直接相连)。
    *   成本可以由网络运营商定义，例如：
        *   总是为 1 (跳数最少)。
        *   与带宽成反比 (带宽越高，成本越低)。
        *   与拥塞程度相关。

#### 1.3 路由算法分类 ↔️↕️

路由算法可以从不同维度进行分类：

1.  **信息范围**:
    *   **全局式 (Global)**: 所有路由器拥有完整的网络拓扑和链路成本信息。
        *   代表算法: **链路状态 (Link State, LS) 算法**。
    *   **分布式/分散式 (Decentralized)**: 路由器只知道其直连邻居的链路成本，通过与邻居迭代计算和交换信息来逐步确定路由。
        *   代表算法: **距离向量 (Distance Vector, DV) 算法**。

2.  **路由变化频率**:
    *   **静态 (Static)**: 路由变化缓慢，通常由人工配置。
    *   **动态 (Dynamic)**: 路由会随着网络拓扑或链路成本的变化（如周期性更新或响应链路变化）而快速改变。

---

### 2. 链路状态 (LS) 路由算法 (Link State Algorithms) 🗺️

#### 2.1 Dijkstra 算法 (Dijkstra's Link-State Routing Algorithm)

*   **核心思想**:
    *   **集中式计算**: 每个节点都拥有整个网络的拓扑图和所有链路的成本 (通过 "链路状态广播" 实现，所有节点信息一致)。
    *   **计算最短路径**: 从一个源节点出发，计算到所有其他节点的最短路径。
    *   **生成转发表**: 基于计算出的最短路径，为该源节点生成转发表。
    *   **迭代**: 经过 $k$ 次迭代后，能够知道到 $k$ 个目的地的最短路径。

*   **符号约定** 📖:
    *   $\boxed{c_{x,y}}$: 节点 $x$到节点 $y$ 的直连链路成本；如果 $x, y$ 不直接相连，则为 $\infty$。
    *   $\boxed{D(v)}$: 从源节点到目的节点 $v$ 的当前路径成本估计值。
    *   $\boxed{p(v)}$: 从源节点到 $v$ 的路径上，$v$ 的前驱节点。
    *   $\boxed{N'}$: 已经确定了最短路径的节点集合。

*   **算法步骤** (以节点 $u$ 为源):
    1.  **初始化 (Initialization)**:
        *   $N' = \{u\}$ (初始时，只有源节点 $u$ 在 $N'$ 中)
        *   对于所有节点 $v$:
            *   如果 $v$ 与 $u$ 相邻，则 $D(v) = c_{u,v}$
            *   否则，$D(v) = \infty$
    2.  **循环 (Loop)**:
        *   **找到最近的节点**: 在 $N'$ 之外找到节点 $w$，使得 $D(w)$ 最小。
        *   **加入 $N'$**: 将 $w$ 加入 $N'$。
        *   **更新邻居距离**: 对于 $w$ 的每个不在 $N'$ 中的邻居 $v$:
            *   $\boxed{D(v) = \min( D(v), D(w) + c_{w,v} )}$ (核心更新步骤：比较经过 $w$ 到达 $v$ 的路径是否更短)
    3.  **终止**: 直到所有节点都在 $N'$ 中。

*   **Dijkstra 算法示例** 💡:
![](Pic/Pasted%20image%2020250508203327.png)
![](Pic/Pasted%20image%2020250508203338.png)

*   **Dijkstra算法讨论** 🗣️:
	*   **算法复杂度** (设 $N$ 为节点数, $E$ 为链路数):
	    *   **朴素实现 (基于数组/列表)**:
	        *   算法进行 $N$ 轮迭代。在每一轮中，需要从未确定最短路径的节点中找到距离最小的节点。若通过线性扫描实现，此步骤需要 $O(N)$ 次比较。
	        *   总的比较次数接近 $N(N-1)/2$ ，这部分操作的时间复杂度为 $O(N^2)$。考虑到更新距离的操作 (总共 $O(E)$)，整体复杂度为 $\boxed{O(N^2 + E)}$，通常简化为 $\boxed{O(N^2)}$ (因为在稠密图中 $E \approx N^2$，在稀疏图中 $N^2$ 也会主导 $E$）。
	    *   **优先队列优化**:
	        *   通过使用更高效的数据结构——优先队列来管理节点距离，可以显著降低时间复杂度。
	        *   若使用**二叉堆 (Binary Heap)**，每次提取最小节点和更新节点距离的操作为 $O(\log N)$，总复杂度为 $\boxed{O((N+E)\log N)}$，通常对于连通图 (其中 $E \ge N-1$) 简化为 $\boxed{O(E \log N)}$。
	        *   若使用**斐波那契堆 (Fibonacci Heap)**，更新节点距离的摊销时间为 $O(1)$，提取最小节点为 $O(\log N)$，总复杂度可以达到 $\boxed{O(N \log N + E)}$。
	**消息复杂度 (Link-State Routing)** 🗣️:
	
	*   **目标**: 所有 $N$ 个路由器都需要获取全网的链路状态信息。
	*   **过程**:
	    1.  每个路由器 (共 $N$ 个) 广播其自身的链路状态信息 (LSA)。
	    2.  **一个** LSA 通过泛洪机制传播到全网，其在网络中总共穿越的链路数量级为 $O(N)$ 。
	*   **总消息复杂度**:
	    *   由于有 $N$ 个路由器各自发起一次这样的广播，总的链路传输次数（或网络负载）为:
	        $N \text{ (个广播源)} \times O(N) \text{ (每次广播的链路穿越量)} = \boxed{O(N^2)}$
*   **Dijkstra 算法的振荡问题** ⚠️:
    *   当链路成本依赖于该链路上的流量时，可能会发生路由振荡。
    *   **场景**: 假设有4个节点 a, b, c, d。目标是到达 a。流量从 d, c, b 进入，速率分别为 1, e (<1), 1。链路成本是流量的函数。
        1.  **初始**: 假设所有节点都选择某条路径，导致该路径成本上升。
        2.  **调整**: 节点重新计算最短路径，可能选择另一条先前成本较高的路径。
        3.  **再调整**: 新的选择又导致新路径成本上升，旧路径成本下降。
        4.  **循环**: 如此反复，导致路由不稳定，在不同路径间振荡。
    *   **解决方法**: 可以通过限制成本更新频率、使用非线性成本函数或确保所有路由器不同时更新路由来缓解。

---

### 3. 距离向量 (DV) 路由算法 (Distance Vector Algorithms) 🧭

#### 3.1 Bellman-Ford 方程 🔢

DV 算法基于 Bellman-Ford 方程 (一种动态规划方法)：

*   令 $\boxed{D_x(y)}$ 表示从节点 $x$ 到节点 $y$ 的最小成本路径的成本。
*   Bellman-Ford 方程:
    $\boxed{D_x(y) = \min_{v \in neighbors(x)} \{ c_{x,v} + D_v(y) \}}$
    *   $c_{x,v}$ 是从 $x$ 到其邻居 $v$ 的链路成本。
    *   $D_v(y)$ 是邻居 $v$ 估计的到目的地 $y$ 的最小成本。
    *   $x$ 通过比较所有经由其邻居 $v$ 到达 $y$ 的路径成本，选择最小的一个作为 $D_x(y)$。

*   **示例 (P5-21)**: 节点 $u$ 要计算到 $z$ 的最短路径 $D_u(z)$。
    *   $u$ 的邻居有 $v, x, w$。
    *   $u$ 知道到 $v, x, w$ 的成本: $c_{u,v}=2, c_{u,x}=1, c_{u,w}=5$。
    *   $u$ 从邻居处获知它们的 $D_v(z)=5, D_x(z)=3, D_w(z)=3$。
    *   $D_u(z) = \min \{ (c_{u,v} + D_v(z)), (c_{u,x} + D_x(z)), (c_{u,w} + D_w(z)) \}$
    *   $D_u(z) = \min \{ (2+5), (1+3), (5+3) \} = \min \{7, 4, 8\} = \boxed{4}$
    *   因此，$u$ 到 $z$ 的下一跳是 $x$。

#### 3.2 DV 算法核心思想 💡

*   每个节点 $x$ 维护一个距离向量 $\vec{D_x} = [D_x(y_1), D_x(y_2), ..., D_x(y_N)]$，其中 $D_x(y_i)$ 是 $x$ 到网络中所有其他节点 $y_i$ 的当前最小成本估计。
*   **周期性/事件驱动**: 每个节点会周期性地或在本地链路成本改变/收到邻居DV更新时，将其自身的距离向量发送给所有邻居。
*   **更新**: 当节点 $x$ 从任何邻居 $v$ 收到新的DV估计 $\vec{D_v}$ 时，它使用 Bellman-Ford 方程更新自己的距离向量 $\vec{D_x}$：
    对于每个目的地 $y \in N$: $D_x(y) \leftarrow \min_{v \in neighbors(x)} \{c_{x,v} + D_v(y)\}$
*   在适当条件下 (例如没有负权环路)，各节点的 $D_x(y)$ 会收敛到实际的最小成本 $d_x(y)$。

#### 3.3 DV 算法特性与流程 ⚙️

*   **迭代 (Iterative)**, **异步 (Asynchronous)**:
    *   本地迭代由本地链路成本变化或从邻居收到的 DV 更新消息触发。
    *   节点不需同步操作。
*   **分布式 (Distributed)**, **自终止 (Self-stopping)**:
    *   每个节点仅在其 DV 发生变化时才通知邻居。
    *   邻居再通知它们的邻居 (仅当必要时)。
    *   如果没有收到通知，则不采取行动。
*   **节点行为流程**:
    ```
    Loop:
      wait (for change in local link cost OR message from neighbor)
      recompute DV estimates (using DV received from neighbor and Bellman-Ford)
      if DV to any destination has changed:
        notify neighbors
    ```

#### 3.4 DV 算法示例 📊

*   **初始化**: 每个节点只知道到其直连邻居的成本，到其他节点的成本为 $\infty$。
*   **迭代**:
    *   **t=0**: 节点交换初始DV。
    *   **t=1**: 节点根据收到的DV和Bellman-Ford方程重新计算自己的DV。如果DV改变，则通告给邻居。
        *   例如 (P5-33)，节点 $b$ 从 $a, c, e$ 收到DV后，重新计算其到所有节点的距离。
        *   $D_b(a) = \min\{c_{b,a}+D_a(a), c_{b,c}+D_c(a), c_{b,e}+D_e(a)\} = \min\{8+0, 1+\infty, 1+\infty\} = 8$
        *   $D_b(d) = \min\{c_{b,a}+D_a(d), c_{b,c}+D_c(d), c_{b,e}+D_e(d)\} = \min\{8+1, 1+\infty, 1+1\} = 2$ (通过e)
    *   **t=2, t=3, ...**: 重复此过程。
*   **信息扩散 (P5-37)**:
    *   在 $t=0$ 时，$c$ 的状态只在 $c$ 处。
    *   在 $t=1$ 时，$c$ 的状态（链路成本信息）已传播到其邻居（如 $b$），并可能影响 $b$ 的DV计算。
    *   在 $t=k$ 时，$c$ 的状态可能已影响到 $k$ 跳远的节点。信息通过迭代的通信和计算步骤在网络中扩散。

#### 3.5 DV 算法与链路成本变化 📉📈

*   **好消息传播快 (Good news travels fast) (P5-38)**:
    *   当一条链路成本降低或一条新链路出现时，这个 "好消息" 会迅速通过网络传播。
    *   例如，如果 $y-z$ 链路成本从4降到1。
        1.  $y$ 检测到变化，更新 $D_y(z)=1$，通知邻居。
        2.  邻居收到更新后，重新计算并可能找到更短的路径，然后通知它们的邻居。
        *   在这个例子中:
            *   $t_0$: $y$ 检测到 $y-x$ 链路成本从4变为1。$y$ 更新其到 $x$ 的距离为1，并通知其邻居 $z$。
            *   $t_1$: $z$ 收到 $y$ 的更新。$z$ 原本到 $x$ 的路径可能是 $z-y-x$ (成本 $1+4=5$)。现在 $z$ 重新计算 $D_z(x) = \min \{ \dots, c_{z,y} + D_y(x) \} = \min \{ \dots, 1+1 \} = 2$。$z$ 更新其DV并通知其邻居 $y$。
            *   $t_2$: $y$ 收到 $z$ 的更新。$y$ 重新计算到 $x$ 的距离，但其直连 $y-x$ 成本为1，仍然是最优的。$y$ 的DV没有变化，所以 $y$ 不会再向 $z$ 发送消息。

*   **坏消息传播慢 (Bad news travels slow) - 计数到无穷问题 (Count-to-infinity problem) (P5-39)** 🐌:   
    *   当一条链路成本增加或断开时，这个 "坏消息" 的传播可能非常缓慢，并可能导致路由环路。
    *   **场景 (P5-39)**: 节点 $y, z$。$x$ 是目的地。
        链路 $y-x$ 成本从4变为60。
        $D_y(x)=4$ (直连), $D_z(x)=5$ (通过 $z-y-x$, $c_{z,y}=1$)。
        1.  $y-x$ 成本变为60。$y$ 现在看到 $D_y(x)=60$ (直连)。但 $y$ 之前从 $z$ 处得知 $D_z(x)=5$，所以 $y$ 认为可以通过 $z$ 到达 $x$，成本为 $c_{y,z} + D_z(x) = 1+5=6$。$y$ 更新 $D_y(x)=6$，下一跳是 $z$。$y$ 通知 $z$。
        2.  $z$ 收到 $y$ 的更新 ($D_y(x)=6$)。$z$ 原本的下一跳是 $y$。$z$ 重新计算 $D_z(x) = c_{z,y} + D_y(x) = 1+6=7$。$z$ 更新 $D_z(x)=7$，下一跳是 $y$。$z$ 通知 $y$。
        3.  $y$ 收到 $z$ 的更新 ($D_z(x)=7$)。$y$ 重新计算 $D_y(x) = c_{y,z} + D_z(x) = 1+7=8$。$y$ 更新 $D_y(x)=8$，下一跳是 $z$。$y$ 通知 $z$。
        4.  ...这个过程会一直持续下去， $D_y(x)$ 和 $D_z(x)$ 的值会缓慢增加，直到它们达到某个代表无穷大的值，或者真正的路径被发现。在此期间， $y$ 和 $z$ 之间形成了到 $x$ 的路由环路 ($y \rightarrow z \rightarrow y \rightarrow \dots$)。
    *   **解决方法**:
        *   **定义最大度量 (Maximum metric)**: 将无穷大定义为一个具体的数值 (如16跳)，超过则认为不可达。
        *   **毒性逆转 (Poison Reverse / Split Horizon with Poison Reverse)**: $A$ 会向 $B$ 通告它通过 $B$ 到达 $X$ 的路径，但成本设为无穷大。

#### 3.6 LS 与 DV 算法比较 ⚖️

| 特性             | 链路状态 (LS)                                     | 距离向量 (DV)                                                                |
| ---------------- | ------------------------------------------------- | ---------------------------------------------------------------------------- |
| **消息复杂度**   | $N$ 个路由器, $O(N^2)$ 或 $O(NE)$ 消息 (广播)     | 仅在邻居间交换；收敛时间变化大                                                 |
| **收敛速度**     | $O(N^2)$ 或 $O(N \log N)$ 算法; 可能有振荡问题     | 收敛时间变化大；可能有路由环路和计数到无穷问题                               |
| **健壮性**       | - 路由器可通告错误的链路成本。<br>- 每个路由器独立计算自己的转发表。 | - DV路由器可通告错误的路径成本 (例如，“我到任何地方成本都很低” -> 黑洞)。<br>- 一个节点的错误会传播到其他节点。 |
| **计算开销**     | 较高 (Dijkstra)                                   | 较低 (Bellman-Ford迭代)                                                      |
| **内存开销**     | 较高 (存储整个拓扑)                               | 较低 (存储到邻居的成本和邻居的DV)                                            |

---

### 📝 本章小结 (已覆盖部分)

1.  **控制平面** 负责网络的路由决策，而 **数据平面** 负责实际的数据包转发。
2.  控制平面实现方式：**传统每路由器控制** vs. **SDN 逻辑集中控制**。
3.  路由算法目标是找到网络中的 "好" 路径，通常基于图论中的最短路径算法。
4.  **链路状态 (LS) 算法** (如 Dijkstra):
    *   全局信息，每个节点计算自己的最短路径树。
    *   消息复杂度高，可能出现振荡。
    *   核心公式: $\boxed{D(v) = \min( D(v), D(w) + c_{w,v} )}$
5.  **距离向量 (DV) 算法** (如 Bellman-Ford):
    *   分布式，节点仅与邻居交换信息。
    *   可能存在计数到无穷问题和路由环路。
    *   核心公式: $\boxed{D_x(y) = \min_{v \in neighbors(x)} \{ c_{x,v} + D_v(y) \}}$

---

**(后续内容 OSPF, BGP, SDN, ICMP, SNMP/NETCONF 将在 PDF 后续部分展开)**